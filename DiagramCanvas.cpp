#include "DiagramCanvas.h"
#include "ConnectorShape.h"
#include <QPainter>
#include <QPaintEvent>
#include <QMouseEvent>
#include <QKeyEvent>
#include <QColorDialog>
#include <QInputDialog>
#include <QMenu>
#include <QFileDialog>
#include <QSvgGenerator>
#include <QApplication>
#include <QClipboard>
#include <QMimeData>
#include <QBuffer>
#include <QDebug>

DiagramCanvas::DiagramCanvas(QWidget* parent)
    : QWidget(parent)
    , m_backgroundColor(Qt::white)
    , m_canvasSize(1200, 800)
    , m_modified(false)
    , m_isDragging(false)
    , m_isCreating(false)
    , m_isResizing(false)
    , m_resizeHandle(-1)
    , m_activeShapeTool(DiagramShape::None)
    , m_isConnecting(false)
    , m_startConnectShape(nullptr)
{
    setMinimumSize(600, 400);
    setFocusPolicy(Qt::StrongFocus);
    setAcceptDrops(true);
}

void DiagramCanvas::addShape(std::shared_ptr<DiagramShape> shape)
{
    if (shape) {
        m_shapes.append(shape);
        m_modified = true;
        update();
    }
}

void DiagramCanvas::clear()
{
    m_shapes.clear();
    m_selectedShape = nullptr;
    m_selectedShapes.clear();
    m_modified = false;
    update();
    emit selectionChanged(false);
}

bool DiagramCanvas::exportToPng(const QString& filename)
{
    QPixmap pixmap(m_canvasSize);
    pixmap.fill(m_backgroundColor);

    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);

    for (auto& shape : m_shapes) {
        shape->paint(&painter);
    }

    return pixmap.save(filename, "PNG");
}

bool DiagramCanvas::exportToSvg(const QString& filename)
{
    QSvgGenerator generator;
    generator.setFileName(filename);
    generator.setSize(m_canvasSize);
    generator.setViewBox(QRect(0, 0, m_canvasSize.width(), m_canvasSize.height()));
    generator.setTitle("Diagram");
    generator.setDescription("Generated by DiagramEditor");

    QPainter painter(&generator);
    painter.setRenderHint(QPainter::Antialiasing);

    painter.fillRect(QRect(0, 0, m_canvasSize.width(), m_canvasSize.height()), m_backgroundColor);

    for (auto& shape : m_shapes) {
        shape->paint(&painter);
    }

    return true;
}

void DiagramCanvas::setAllShapes(const QList<std::shared_ptr<DiagramShape>>& shapes)
{
    m_shapes = shapes;
    m_selectedShape = nullptr;
    m_selectedShapes.clear();
    update();
    emit selectionChanged(false);
}

void DiagramCanvas::bringToFront()
{
    if (!m_selectedShape) return;
    m_shapes.removeOne(m_selectedShape);
    m_shapes.append(m_selectedShape);
    m_modified = true;
    update();
}

void DiagramCanvas::sendToBack()
{
    if (!m_selectedShape) return;
    m_shapes.removeOne(m_selectedShape);
    m_shapes.prepend(m_selectedShape);
    m_modified = true;
    update();
}

void DiagramCanvas::bringForward()
{
    if (!m_selectedShape) return;
    int index = m_shapes.indexOf(m_selectedShape);
    if (index < m_shapes.size() - 1) {
        m_shapes.removeAt(index);
        m_shapes.insert(index + 1, m_selectedShape);
        m_modified = true;
        update();
    }
}

void DiagramCanvas::sendBackward()
{
    if (!m_selectedShape) return;
    int index = m_shapes.indexOf(m_selectedShape);
    if (index > 0) {
        m_shapes.removeAt(index);
        m_shapes.insert(index - 1, m_selectedShape);
        m_modified = true;
        update();
    }
}

void DiagramCanvas::chooseBackgroundColor()
{
    QColor color = QColorDialog::getColor(m_backgroundColor, this, tr("选择背景颜色"));
    if (color.isValid()) {
        m_backgroundColor = color;
        m_modified = true;
        update();
    }
}

void DiagramCanvas::setCanvasSize()
{
    bool ok;
    int width = QInputDialog::getInt(this, tr("设置宽度"), tr("宽度 (像素):"), m_canvasSize.width(), 200, 5000, 10, &ok);
    if (!ok) return;
    int height = QInputDialog::getInt(this, tr("设置高度"), tr("高度 (像素):"), m_canvasSize.height(), 200, 5000, 10, &ok);
    if (!ok) return;
    m_canvasSize = QSize(width, height);
    resize(m_canvasSize);
    m_modified = true;
    update();
}

void DiagramCanvas::copySelectedToClipboard()
{
    if (!m_selectedShape) return;

    QByteArray itemData;
    QDataStream dataStream(&itemData, QIODevice::WriteOnly);

    m_selectedShape->save(dataStream);

    QMimeData* mimeData = new QMimeData;
    mimeData->setData("application/x-flowchart-shape", itemData);

    QApplication::clipboard()->setMimeData(mimeData);
}

void DiagramCanvas::cutSelectedToClipboard()
{
    if (!m_selectedShape) return;

    copySelectedToClipboard();
    deleteSelected();
}

void DiagramCanvas::pasteFromClipboard()
{
    const QMimeData* mimeData = QApplication::clipboard()->mimeData();

    if (mimeData->hasFormat("application/x-flowchart-shape")) {
        QByteArray itemData = mimeData->data("application/x-flowchart-shape");
        QDataStream dataStream(&itemData, QIODevice::ReadOnly);

        int type;
        dataStream >> type;

        auto newShape = DiagramShape::createShape((DiagramShape::Type)type);
        if (newShape) {
            dataStream.device()->seek(0);
            newShape->load(dataStream);
            newShape->moveBy(QPointF(20, 20));
            addShape(newShape);
            m_selectedShape = newShape;
            updateSelectionState();
            m_modified = true;
        }
    }
}

void DiagramCanvas::duplicateSelected()
{
    if (!m_selectedShape) return;

    QByteArray itemData;
    QDataStream dataStream(&itemData, QIODevice::WriteOnly);

    m_selectedShape->save(dataStream);

    int type = (int)m_selectedShape->getType();
    auto newShape = DiagramShape::createShape((DiagramShape::Type)type);

    if (newShape) {
        dataStream.device()->seek(0);
        newShape->load(dataStream);
        newShape->moveBy(QPointF(20, 20));
        addShape(newShape);
        m_selectedShape = newShape;
        updateSelectionState();
        m_modified = true;
    }
}

void DiagramCanvas::deleteSelected()
{
    if (!m_selectedShape) return;
    m_shapes.removeOne(m_selectedShape);
    m_selectedShape = nullptr;
    updateSelectionState();
    m_modified = true;
    update();
}

void DiagramCanvas::setActiveShapeTool(int type)
{
    m_activeShapeTool = (DiagramShape::Type)type;
    setCursor(m_activeShapeTool == DiagramShape::None ? Qt::ArrowCursor : Qt::CrossCursor);
}

void DiagramCanvas::paintEvent(QPaintEvent* /*event*/)
{
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);
    painter.fillRect(rect(), m_backgroundColor);
    for (auto& shape : m_shapes) {
        shape->paint(&painter);
    }
    if (m_isConnecting && m_startConnectShape) {
        painter.setPen(QPen(Qt::darkGray, 1, Qt::DashLine));
        painter.drawLine(m_connectStartPoint, m_lastMousePos);
    }
}

void DiagramCanvas::mousePressEvent(QMouseEvent* event)
{
    m_lastMousePos = event->pos();

    if (m_activeShapeTool != DiagramShape::None) {
        if (event->button() == Qt::LeftButton) {
            createNewShape(m_activeShapeTool, event->pos());
            m_isCreating = true;
        }
    }
    else {
        if (event->button() == Qt::LeftButton) {
            auto shape = findShapeAt(event->pos());

            if (shape) {
                if (!(event->modifiers() & Qt::ControlModifier)) {
                    for (auto& s : m_selectedShapes) {
                        s->setSelected(false);
                    }
                    m_selectedShapes.clear();
                }

                m_selectedShape = shape;
                m_selectedShape->setSelected(true);

                if (!m_selectedShapes.contains(m_selectedShape)) {
                    m_selectedShapes.append(m_selectedShape);
                }

                updateSelectionState();

                if (event->modifiers() & Qt::ShiftModifier) {
                    m_isConnecting = true;
                    m_startConnectShape = shape;
                    m_connectStartPoint = event->pos();
                }
                else {
                    m_isDragging = true;
                }

                update();
            }
            else {
                for (auto& s : m_selectedShapes) {
                    s->setSelected(false);
                }
                m_selectedShape = nullptr;
                m_selectedShapes.clear();
                updateSelectionState();
                update();
            }
        }
    }
}

void DiagramCanvas::mouseMoveEvent(QMouseEvent* event)
{
    QPointF delta = event->pos() - m_lastMousePos;

    if (m_isCreating && m_selectedShape) {
        QSizeF newSize(
            qAbs(event->pos().x() - m_selectedShape->getPos().x()),
            qAbs(event->pos().y() - m_selectedShape->getPos().y())
        );
        m_selectedShape->setSize(newSize);
        m_modified = true;
        update();
    }
    else if (m_isDragging && m_selectedShape) {
        for (auto& shape : m_selectedShapes) {
            shape->moveBy(delta);
        }
        m_modified = true;
        update();
    }
    else if (m_isConnecting) {
        m_lastMousePos = event->pos();
        update();
    }

    m_lastMousePos = event->pos();
}

void DiagramCanvas::mouseReleaseEvent(QMouseEvent* event)
{
    if (m_isCreating) {
        m_isCreating = false;
        if (m_selectedShape) {
            emit shapeSelected(m_selectedShape);
        }
    }
    else if (m_isDragging) {
        m_isDragging = false;
    }
    else if (m_isConnecting) {
        auto endShape = findShapeAt(event->pos());
        if (endShape && endShape != m_startConnectShape) {
            auto connector = std::make_shared<ConnectorShape>();
            connector->setStartPoint(m_connectStartPoint);
            connector->setEndPoint(event->pos());
            addShape(connector);
            m_selectedShape = connector;
            updateSelectionState();
        }
        m_isConnecting = false;
        m_startConnectShape = nullptr;
        update();
    }
}

void DiagramCanvas::mouseDoubleClickEvent(QMouseEvent* event)
{
    auto shape = findShapeAt(event->pos());
    if (shape) {
        bool ok;
        QString text = QInputDialog::getText(this, tr("编辑文本"),
            tr("文本:"), QLineEdit::Normal,
            shape->getText(), &ok);
        if (ok) {
            shape->setText(text);
            m_modified = true;
            update();
        }
    }
}

void DiagramCanvas::keyPressEvent(QKeyEvent* event)
{
    switch (event->key()) {
    case Qt::Key_Delete:
        deleteSelected();
        break;
    case Qt::Key_Escape:
        if (m_isCreating || m_isDragging || m_isConnecting) {
            m_isCreating = false;
            m_isDragging = false;
            m_isConnecting = false;
            update();
        }
        break;
    case Qt::Key_C:
        if (event->modifiers() & Qt::ControlModifier) {
            copySelectedToClipboard();
        }
        break;
    case Qt::Key_X:
        if (event->modifiers() & Qt::ControlModifier) {
            cutSelectedToClipboard();
        }
        break;
    case Qt::Key_V:
        if (event->modifiers() & Qt::ControlModifier) {
            pasteFromClipboard();
        }
        break;
    case Qt::Key_D:
        if (event->modifiers() & Qt::ControlModifier) {
            duplicateSelected();
        }
        break;
    }
}

void DiagramCanvas::contextMenuEvent(QContextMenuEvent* event)
{
    QMenu menu(this);

    auto shape = findShapeAt(event->pos());
    if (shape) {
        m_selectedShape = shape;
        shape->setSelected(true);
        updateSelectionState();
        update();

        QAction* copyAction = menu.addAction(tr("复制"));
        QAction* cutAction = menu.addAction(tr("剪切"));
        QAction* deleteAction = menu.addAction(tr("删除"));

        menu.addSeparator();
        QAction* bringToFrontAction = menu.addAction(tr("置于顶层"));
        QAction* sendToBackAction = menu.addAction(tr("置于底层"));

        connect(copyAction, &QAction::triggered, this, &DiagramCanvas::copySelectedToClipboard);
        connect(cutAction, &QAction::triggered, this, &DiagramCanvas::cutSelectedToClipboard);
        connect(deleteAction, &QAction::triggered, this, &DiagramCanvas::deleteSelected);
        connect(bringToFrontAction, &QAction::triggered, this, &DiagramCanvas::bringToFront);
        connect(sendToBackAction, &QAction::triggered, this, &DiagramCanvas::sendToBack);
    }
    else {
        QAction* pasteAction = menu.addAction(tr("粘贴"));
        connect(pasteAction, &QAction::triggered, this, &DiagramCanvas::pasteFromClipboard);
    }

    menu.exec(event->globalPos());
}

std::shared_ptr<DiagramShape> DiagramCanvas::findShapeAt(const QPointF& pos)
{
    for (int i = m_shapes.size() - 1; i >= 0; --i) {
        if (m_shapes[i]->contains(pos)) {
            return m_shapes[i];
        }
    }
    return nullptr;
}

void DiagramCanvas::createNewShape(DiagramShape::Type type, const QPointF& pos)
{
    auto shape = DiagramShape::createShape(type);
    if (shape) {
        shape->setPos(pos);
        addShape(shape);

        m_selectedShape = shape;
        shape->setSelected(true);
        updateSelectionState();
        m_modified = true;
    }
}

void DiagramCanvas::updateSelectionState()
{
    emit shapeSelected(m_selectedShape);
    emit selectionChanged(m_selectedShape != nullptr);
}

void DiagramCanvas::refreshCanvas() {
    update();
}